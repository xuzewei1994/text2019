<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
</body>
<script>
	// function fn(){
	// 	var a = 1;
	// 	console.log("fn = ",a);
	// 	function fn2(){
	// 		console.log("fn2 = ",a);
	// 	}
	// 	fn2();	
	// }
	// fn();
	// console.log("global = ",a);
	// 
	// 
	// var a = 10;
	// function test(){
 //    	a = 100;
 //    	console.log("text1 = ",a);
 //    	console.log("text2 = ",this.a);
 //    	var a;
 //     console.log("text3 = ",a);
	// }
	// test();
	/*解析：Javascript在执行前会对整个脚本文件的声明部分做完整分析(包括局部变量)，从而确定变量的作用域，所以在函数test执行前，由于第6行声明了局部变量a，所以函数内部的a都指向已经声明的局部变量，所以第4行输出100。第5行输出this.a，我们都知道，函数内部的this指针指向的是函数的调用者，在这里函数test被全局对象调用，所以this指针指向全局对象（这里即window），所以this.a = window.a，一开始生命了全局变量a=10，所以第5行输出结果为10。第7行输出结果为100，因为局部变量a在第3行已经被赋值了100，所以直接输出局部变量a的值。
	*/


	// var a = 100;
	// function test(){
 //    	console.log("text = ",a);
 //    	var a = 10;
 //    	console.log(a);
	// }
	// test();
	/*解析：看了第1个例子，可能有同学会认为输出结果是10  10，但是结果却不是10 10，为什么呢？仔细看第1个例子解析的第一句话，Javascript在执行前会对整个脚本文件的声明部分做完整分析(包括局部变量)，但是不能对变量定义做提前解析，在这个函数中，执行第3行前，可以认为已经声明了变量a，但是并没有定义（这里即赋值），所以第3行输出结果为undefined，执行第4行a =10后，变量a的值就为10，所以第5行输出结果为10。
	*/
	var a = 100;
	function test(){
   		console.log("text1 = ",a);//10
    	a = 10;
    	console.log("text2 = ",a);//10
	}
	test();
	console.log("text3 = ",a);//100
	/*解析：我们知道在函数内部，一般用var声明的为局部变量，没用var声明的一般为全局变量，在test函数内，a=10声明了一个全局变量，所以第3行的a应该输出全局变量的值，而在函数执行之前已经声明过一个全局变量并赋值100，所以这里第上输出100。第4行给全局变量a 重新赋值10，所以全局变量a的值变成10，所以第5行输出10。而在函数test外部，第8行输出全局变量a的值，因为全局变量被重新赋值为10，所以输出结果即为10。
	*/
</script>
</html>